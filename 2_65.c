#include <stdio.h>

/*
 * Return 1 when x contains an odd number of 1s; 0 otherwise. Assume w = 32.
 * 1）分别计算原始x(1，17)，(2, 18)，(3, 19)，(4, 20)，(5, 21)，(6, 22)，(7, 23)，(8, 24)，
 *    (9, 25)，(10, 26)，(11, 27)，(12, 28)，(13, 29)，(14, 30)，(15, 31)，(16, 32)
 *    两两位上1的个数的奇偶性
 *     00000000000101000000111011011000
 * xor                 00000000000101000000111011011000
 * ------------------------------------
 *     00000000000101000000111011001100
 * 右起第1个0表示原来x的1，17位上1的个数是偶数个，右起第2个0表示原来x的2，18位上1的个数是偶数个，右起第1个1表示原来x的3，19位上1的个数是奇数个（0 + 1 = 1）
 * 依此类推，只看新的x的低16位，每一位承载着原始x的2个位上1的个数的奇偶性信息，高16位忽略
 *
 * 2) 分别计算原始x(1, 17, 9, 25)，(2, 18, 10, 26)，(3, 19, 11, 27)，(4, 20, 12, 28)，
 *    (5, 21, 13, 29)，(6, 22, 14, 30)，(7, 23, 15, 31)，(8, 24, 16, 32)每组的4个位上1的个数的奇偶性
 *     00000000000101000000111011001100
 * xor         00000000000101000000111011001100
 * ------------------------------------
 *     00000000000101000001101011000010
 * 右起第1位上的0表示原来x的1，17，9，25位上1的个数是偶数个，右起第2位上的1表示原来x的2，18，10，26位上1的个数是奇数个……依此类推，右起第8位上的1表示原来x的
 * 8，24，16，32位上1的个数是奇数个，只考虑低8位，每一位承载原始x的4个位上1的个数的奇偶性信息
 *
 * 3) 分别计算原始x(1, 17, 9, 25, 5, 21, 13, 29)，(2, 18, 10, 26, 6, 22, 14, 30)，
 *    (3, 19, 11, 27, 4, 20, 12, 28)，(4, 20, 12, 28, 8, 24, 16, 32)每组8个位上1个数的奇偶性
 *     00000000000101000001101011000010
 * xor     00000000000101000001101011000010
 * ------------------------------------
 *     00000000000101010101101101101110
 * 右起第1位上的0表示原始x的1，17，9，25，5，21，13，29位上1的个数是偶数个，右起第2位上的1表示原始x的2，18，10，26，6，22，14，30位上1的个数是奇数个……
 * 依此类推，右起第4位上的1表示原始x的4，20，12，28，8，24，16，32位上1的个数是奇数个
 *
 * 4) 分别计算原始x(1, 17, 9, 25, 5, 21, 13, 29, 3, 19, 11, 27, 4, 20, 12, 28)，
 *    (2, 18, 10, 26, 6, 22, 14, 30, 4, 20, 12, 28, 8, 24, 16, 32)每组16个位上1的个数的奇偶性
 *     00000000000101010101101101101110
 * xor   00000000000101010101101101101110
 * ------------------------------------
 *     00000000000100000000110110110101
 * 右起第1位上的1表示原始x的1，17，9，25，5，21，13，29，3，19，11，27，4，20，12，28位上1的个数是奇数个，右起第2位上的0表示原始x其余16位上1的个数的
 * 总和是偶数个
 *
 * 5) 计算原始x所有位上1的个数的奇偶性
 *     00000000000100000000110110110101
 * xor  00000000000100000000110110110101
 * ------------------------------------
 *     00000000000110000000101101101111
 * 右起第1位上的1表示原始x所有位上1的个数的总和是奇数个
 *
 * 当然，为了知道最后一步最后一位上0还是1，与1进行与（&）运算就知道
 */
int odd_ones(unsigned x) {
  x ^= x >> 16;
  x ^= x >> 8;
  x ^= x >> 4;
  x ^= x >> 2;
  x ^= x >> 1;
  return x & 1;
}

/*
 * uname -a
 * Darwin MacBook-Pro 15.0.0 Darwin Kernel Version 15.0.0: Sat Sep 19 15:53:46 PDT 2015; root:xnu-3247.10.11~1/RELEASE_X86_64 x86_64
 * gcc -o main 2_65.c
 * ./main
 * 1
 */
int main(void)
{
  // x = 00000000 00010100 00001110 11011000
  unsigned x = 0x00140ED8;
  printf("%d\n", odd_ones(x));
  return 0;
}
